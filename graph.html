<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CBV Keyword Graph Explorer</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; font-family: 'Segoe UI', sans-serif; overflow: hidden; }
        svg { width: 100%; height: 100%; background: radial-gradient(circle, #1a1a2e 0%, #16213e 100%); }
        
        .node { cursor: pointer; transition: opacity 0.3s ease; }
        .node text { font-size: 12px; pointer-events: none; text-anchor: middle; fill: #fff; font-weight: 600; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); }
        
        .link { stroke: rgba(255, 255, 255, 0.3); stroke-width: 2; transition: opacity 0.3s ease; }
        .link.broader { stroke: rgba(255, 140, 66, 0.6); stroke-width: 2.5; }
        .link.narrower { stroke: rgba(138, 104, 204, 0.6); stroke-width: 2.5; }
        .link.related { stroke: rgba(74, 144, 226, 0.6); stroke-width: 2; }
        .link.members { stroke: rgba(52, 152, 219, 0.6); stroke-width: 2; }
        
        .tooltip { position: absolute; background: rgba(0, 0, 0, 0.9); color: white; padding: 12px; border-radius: 8px; font-size: 14px; z-index: 1000; max-width: 300px; border: 1px solid rgba(255,255,255,0.2); cursor: default; pointer-events: auto; }
        .tooltip-content { pointer-events: none; }
        .tooltip-definition { font-size: 12px; color: #a7d1d2; border-top: 1px solid #444; margin-top: 8px; padding-top: 8px; font-style: italic; }
        .tooltip-translations { font-size: 12px; color: #ccc; border-top: 1px solid #444; margin-top: 8px; padding-top: 8px; }
        .tooltip-close { position: absolute; top: 5px; right: 8px; background: transparent; border: none; color: #aaa; font-size: 20px; cursor: pointer; padding: 0; line-height: 1; }
        .tooltip-close:hover { color: white; }

        .ui-panel { position: absolute; background: rgba(0, 0, 0, 0.8); color: white; padding: 15px; border-radius: 10px; z-index: 1000; backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.2); transition: all 0.3s ease; }
        
        .control-panel { top: 20px; left: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        .control-panel button { background: #667eea; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; transition: background 0.3s ease; font-size: 12px; }
        .control-panel button:hover { background: #764ba2; }
        
        .search-panel { top: 20px; right: 20px; min-width: 300px; }
        .search-input { width: 100%; padding: 10px; border: none; border-radius: 5px; background: rgba(255, 255, 255, 0.9); color: #333; font-size: 14px; outline: none; box-sizing: border-box; }
        .search-suggestions { max-height: 200px; overflow-y: auto; background: white; border-radius: 5px; margin-top: 5px; display: none; }
        .suggestion-item { padding: 10px; cursor: pointer; color: #333; }
        .suggestion-item:hover { background: #667eea; color: white; }
        .current-topic { color: #4ecdc4; font-weight: bold; margin-bottom: 10px; font-size: 16px; }
        
        .language-switcher { margin-top: 10px; display: flex; gap: 5px; }
        .lang-btn { padding: 5px 10px; border: 1px solid #667eea; background: transparent; color: #667eea; border-radius: 3px; cursor: pointer; font-size: 12px; transition: all 0.3s ease; }
        .lang-btn.active, .lang-btn:hover { background: #667eea; color: white; }

        #related-keywords-panel { top: 85px; left: 20px; max-width: 280px; max-height: 70vh; display: none; overflow-y: auto; }
        #related-keywords-panel h3 { margin-top: 0; margin-bottom: 10px; font-size: 16px; color: #ff6b6b; border-bottom: 1px solid #ff6b6b; padding-bottom: 8px; }
        .relationship-section { margin-bottom: 15px; }
        #related-content { max-height: calc(70vh - 60px); overflow-y: auto; }
        .relationship-title { font-size: 14px; font-weight: bold; margin-bottom: 5px; color: #4a90e2; }
        .relationship-title.broader { color: #ff8c42; }
        .relationship-title.narrower { color: #8a68cc; }
        .relationship-title.related { color: #4a90e2; }
        .relationship-title.members { color: #3498db; }
        .relationship-title.translation { color: #95a5a6; }
        .relationship-search input { width: 100%; padding: 4px 8px; border: 1px solid #555; border-radius: 3px; background: rgba(255, 255, 255, 0.9); color: #333; font-size: 12px; outline: none; box-sizing: border-box; }
        #related-keywords-panel ul { list-style: none; padding: 0; margin: 0 0 10px 0; max-height: 120px; overflow-y: auto; }
        #related-keywords-panel li a { color: #eee; text-decoration: none; display: block; padding: 6px; border-radius: 3px; transition: background 0.2s ease; font-size: 13px; }
        #related-keywords-panel li a:hover { background: #667eea; }
        #related-keywords-panel li.hidden { display: none; }

        #legend { bottom: 20px; right: 20px; }
        .legend-item { display: flex; align-items: center; margin-bottom: 8px; }
        .legend-color { width: 12px; height: 12px; border-radius: 50%; margin-right: 8px; }
        .legend-color.broader-shape { border-radius: 0; transform: rotate(45deg); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .legend-color.narrower-shape { border-radius: 0; transform: rotate(-135deg); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); }
        .legend-color.diamond-shape { border-radius: 0; transform: rotate(45deg); }
    </style>
    <script src="https://d3js.org/d3.v7.min.js"></script>
</head>
<body>
    <!-- UI Panels -->
    <div class="ui-panel control-panel">
        <button id="main-menu-btn">üè† Main Menu</button>
        <button id="reset-zoom-btn">üîç Reset Zoom</button>
    </div>

    <div class="ui-panel search-panel">
        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
            <div class="current-topic" id="current-topic" style="margin-bottom: 0;"></div>
            <a href="#" id="current-topic-cbv-link" target="_blank" style="color: #4ecdc4; text-decoration: none; font-size: 14px; display: none;" title="View current topic in CBV Source">üîó</a>
        </div>
        <input type="text" class="search-input" id="search-input" autocomplete="off">
        <div class="search-suggestions" id="search-suggestions"></div>
        <div class="language-switcher">
            <button class="lang-btn active" data-lang="en">EN</button>
            <button class="lang-btn" data-lang="fr">FR</button>
            <button class="lang-btn" data-lang="es">ES</button>
        </div>
    </div>

    <div class="ui-panel" id="related-keywords-panel">
        <h3 id="panel-main-title"></h3>
        <div id="related-content">
            <!-- Relationship sections will be populated by JavaScript -->
        </div>
    </div>

    <div class="ui-panel" id="legend">
        <!-- Legend items will be populated by JavaScript -->
    </div>

    <svg id="graph-container"></svg>
    <div class="tooltip" id="tooltip" style="display: none;">
        <button class="tooltip-close" onclick="hideTooltip(true)">√ó</button>
        <div id="tooltip-content" class="tooltip-content"></div>
    </div>

    <script>
        // --- GLOBAL STATE AND CONSTANTS ---
        const width = window.innerWidth;
        const height = window.innerHeight;
        const svg = d3.select("#graph-container");
        const g = svg.append("g");
        const tooltip = d3.select("#tooltip");

        let simulation = null;
        let allKeywords = [];
        let keywordData = {};
        let currentKeyword = '';
        let currentLanguage = 'en';
        let pinnedTooltipNode = null;

        // --- DATA LOADING ---
        /**
         * Loads and processes the keyword data from the JSON file.
         */
        async function loadData() {
            try {
                const response = await fetch('cbv_data.json');
                const data = await response.json();
                keywordData = data;
                allKeywords = Object.keys(keywordData).map(name => ({ name })).sort((a, b) => a.name.localeCompare(b.name));
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('current-topic').textContent = 'Error loading data.';
            }
        }

        // --- D3 GRAPH RENDERING ---
        /**
         * Main function to draw or redraw the entire graph.
         * @param {string} keywordName - The central keyword for the graph.
         */
        function drawGraph(keywordName) {
            if (simulation) simulation.stop();
            g.selectAll("*").remove();
            hideTooltip(true);

            currentKeyword = keywordName;
            const keywordInfo = keywordData[keywordName];
            if (!keywordInfo) {
                console.error(`Keyword "${keywordName}" not found.`);
                return;
            }

            updateCurrentTopicDisplay(keywordName);

            const { nodes, links } = buildGraphData(keywordName, keywordInfo);
            renderGraph({ nodes, links });
            updateRelatedKeywordsPanel(keywordName, keywordInfo);
        }

        /**
         * Constructs the nodes and links arrays for the D3 simulation.
         * @param {string} keywordName - The central keyword.
         * @param {object} keywordInfo - The data object for the central keyword.
         * @returns {{nodes: Array, links: Array}}
         */
        function buildGraphData(keywordName, keywordInfo) {
            const nodes = [{ id: keywordName, name: keywordName, type: 'central' }];
            const links = [];
            const relationshipTypes = ['broader', 'narrower', 'related', 'members'];

            relationshipTypes.forEach(type => {
                (keywordInfo[type] || []).forEach(relatedKeyword => {
                    if (keywordData[relatedKeyword] && !nodes.find(n => n.id === relatedKeyword)) {
                        nodes.push({ id: relatedKeyword, name: relatedKeyword, type });
                        links.push({ source: keywordName, target: relatedKeyword, type });
                    }
                });
            });
            return { nodes, links };
        }

        /**
         * Renders the graph elements using D3.
         * @param {object} graph - The graph data containing nodes and links.
         */
        function renderGraph(graph) {
            const centerX = width / 2;
            const centerY = height / 2;

            // Position nodes in a circular layout
            const angleSlice = (2 * Math.PI) / (graph.nodes.length - 1);
            const radius = Math.min(width, height) * 0.3;
            graph.nodes.forEach((node, i) => {
                if (node.type === 'central') {
                    node.fx = centerX;
                    node.fy = centerY;
                } else {
                    const angle = angleSlice * (i - 1);
                    node.x = centerX + radius * Math.cos(angle);
                    node.y = centerY + radius * Math.sin(angle);
                }
            });

            simulation = d3.forceSimulation(graph.nodes)
                .force("link", d3.forceLink(graph.links).id(d => d.id).strength(0.1))
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(centerX, centerY))
                .force("collision", d3.forceCollide().radius(d => getNodeRadius(d) + 15));

            const link = g.append("g").selectAll("line")
                .data(graph.links).join("line")
                .attr("class", d => `link ${d.type}`);

            const node = g.append("g").selectAll("g")
                .data(graph.nodes).join("g")
                .attr("class", "node")
                .call(drag(simulation))
                .on("click", handleNodeClick)
                .on("dblclick", handleNodeDblClick)
                .on("mouseover", handleNodeMouseover)
                .on("mouseout", handleNodeMouseout);

            // Append shapes and text to nodes
            node.each(function(d) {
                const nodeElement = d3.select(this);
                const radius = getNodeRadius(d);
                const color = getNodeColor(d);
                
                if (d.type === 'central') nodeElement.append("circle").attr("r", radius).attr("fill", color);
                else if (d.type === 'broader') nodeElement.append("polygon").attr("points", `0,${-radius*1.4} ${radius*1.2},${radius*0.7} ${-radius*1.2},${radius*0.7}`).attr("fill", color);
                else if (d.type === 'narrower') nodeElement.append("polygon").attr("points", `0,${radius*1.4} ${radius*1.2},${-radius*0.7} ${-radius*1.2},${-radius*0.7}`).attr("fill", color);
                else if (d.type === 'related') nodeElement.append("polygon").attr("points", `0,${-radius*1.2} ${radius*1.2},0 0,${radius*1.2} ${-radius*1.2},0`).attr("fill", color);
                else nodeElement.append("circle").attr("r", radius).attr("fill", color);
            });

            node.append("text")
                .text(d => getDisplayLabel(d.name))
                .attr("dy", d => -getNodeRadius(d) - 8)
                .attr("class", "node-label");

            simulation.on("tick", () => {
                link.attr("x1", d => d.source.x).attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x).attr("y2", d => d.target.y);
                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });
        }

        // --- UI & EVENT HANDLING ---
        /**
         * Initializes all event listeners for UI elements.
         */
        function initializeEventListeners() {
            d3.select("#main-menu-btn").on("click", () => window.location.href = 'index.html');
            d3.select("#reset-zoom-btn").on("click", resetZoom);
            d3.selectAll(".lang-btn").on("click", (event) => switchLanguage(event.target.dataset.lang));
            svg.on('click', () => hideTooltip(true));
            setupSearch();
        }

        function handleNodeClick(event, d) {
            event.stopPropagation();
            if (pinnedTooltipNode === d) {
                pinnedTooltipNode = null;
                hideTooltip();
            } else {
                pinnedTooltipNode = d;
                showTooltip(event, d);
            }
        }

        function handleNodeDblClick(event, d) {
            if (d.type !== 'central') {
                navigateToTopic(d.name);
            }
        }

        function handleNodeMouseover(event, d) {
            if (!pinnedTooltipNode) {
                showTooltip(event, d);
            }
            highlightRelated(d);
        }

        function handleNodeMouseout() {
            if (!pinnedTooltipNode) {
                hideTooltip();
            }
            resetHighlight();
        }

        /**
         * Sets up the search input with autocomplete suggestions.
         */
        function setupSearch() {
            const searchInput = document.getElementById('search-input');
            const suggestions = document.getElementById('search-suggestions');

            searchInput.addEventListener('input', function() {
                const query = this.value.toLowerCase().trim();
                if (!query) {
                    suggestions.style.display = 'none';
                    return;
                }
                const filtered = allKeywords.filter(k => k.name.toLowerCase().includes(query)).slice(0, 8);
                suggestions.innerHTML = filtered.map(k => `<div class="suggestion-item" data-keyword="${k.name}">${k.name}</div>`).join('');
                suggestions.style.display = 'block';
            });

            suggestions.addEventListener('click', function(e) {
                if (e.target.classList.contains('suggestion-item')) {
                    navigateToTopic(e.target.dataset.keyword);
                }
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest('.search-panel')) {
                    suggestions.style.display = 'none';
                }
            });
        }

        /**
         * Updates all text elements on the page to the current language.
         */
        function updateUIText() {
            // Update buttons
            document.getElementById('main-menu-btn').innerHTML = `üè† ${getText('mainMenu')}`;
            document.getElementById('reset-zoom-btn').innerHTML = `üîç ${getText('resetZoom')}`;
            
            // Update search placeholder
            document.getElementById('search-input').placeholder = getText('searchPlaceholder');

            // Update legend
            const legendContainer = d3.select("#legend");
            legendContainer.html(""); // Clear existing legend
            ['centralTopic', 'narrowerTerms', 'broaderTerms', 'relatedTerms', 'collectionMembers'].forEach(key => {
                const item = legendContainer.append("div").attr("class", "legend-item");
                item.append("div").attr("class", `legend-color ${key.replace('Terms', '-shape').replace('Topic', '').replace('Members', '')}`);
                item.append("span").text(getText(key));
            });

            // Update related panel title
            document.getElementById('panel-main-title').textContent = getText('relatedTopics');
        }

        /**
         * Updates the main topic display at the top right.
         * @param {string} keywordName - The keyword to display.
         */
        function updateCurrentTopicDisplay(keywordName) {
            const topicText = getText('topic');
            document.getElementById('current-topic').textContent = `${topicText}: ${getDisplayLabel(keywordName)}`;
            
            const cbvLink = document.getElementById('current-topic-cbv-link');
            const cbvURL = getCBVSourceURL(keywordName);
            cbvLink.href = cbvURL || '#';
            cbvLink.style.display = cbvURL ? 'inline' : 'none';
        }

        /**
         * Populates the related keywords panel on the left.
         * @param {string} keywordName - The central keyword.
         * @param {object} keywordInfo - The data for the central keyword.
         */
        function updateRelatedKeywordsPanel(keywordName, keywordInfo) {
            const panel = document.getElementById('related-keywords-panel');
            const content = document.getElementById('related-content');
            content.innerHTML = ''; // Clear previous content

            const relationshipTypes = ['broader', 'narrower', 'related', 'members'];
            let hasContent = false;

            relationshipTypes.forEach(type => {
                const keywords = keywordInfo[type] || [];
                if (keywords.length > 0) {
                    hasContent = true;
                    const section = document.createElement('div');
                    section.className = 'relationship-section';
                    section.innerHTML = `
                        <div class="relationship-title ${type}">${getText(type + 'Topics')} (${keywords.length})</div>
                        <ul>${keywords.sort().map(item => `<li><a href="#" data-keyword="${item}">${getDisplayLabel(item)}</a></li>`).join('')}</ul>
                    `;
                    content.appendChild(section);
                }
            });

            // Add parent collections
            const parentCollections = findParentCollections(keywordName);
            if (parentCollections.length > 0) {
                hasContent = true;
                const section = document.createElement('div');
                section.className = 'relationship-section';
                section.innerHTML = `
                    <div class="relationship-title parent-collections">${getText('parentCollections')} (${parentCollections.length})</div>
                    <ul>${parentCollections.map(item => `<li><a href="#" data-keyword="${item.name}">${getDisplayLabel(item.name)}</a></li>`).join('')}</ul>
                `;
                content.appendChild(section);
            }

            panel.style.display = hasContent ? 'block' : 'none';
            panel.querySelectorAll('a').forEach(a => a.addEventListener('click', (e) => {
                e.preventDefault();
                navigateToTopic(e.target.dataset.keyword);
            }));
        }

        // --- TOOLTIP ---
        /**
         * Shows the tooltip with information about a node.
         * @param {Event} event - The mouse event.
         * @param {object} d - The D3 data object for the node.
         */
        function showTooltip(event, d) {
            const contentDiv = document.getElementById('tooltip-content');
            let content = `<strong>${getDisplayLabel(d.name)}</strong>`;

            if (d.type !== 'central') {
                content += `<br><span style="font-size: 12px; color: #4ecdc4;">(${getText('doubleClickToExplore')})</span>`;
            }

            const definition = getDefinition(d.name);
            if (definition) {
                content += `<div class="tooltip-definition">${definition}</div>`;
            }

            const translations = getTranslations(d.name);
            if (translations.length > 0) {
                content += `<div class="tooltip-translations">${getText('also')}: ${translations.join(', ')}</div>`;
            }
            
            contentDiv.innerHTML = content;

            const tooltipWidth = tooltip.node().offsetWidth;
            const tooltipHeight = tooltip.node().offsetHeight;
            let left = event.pageX + 15;
            let top = event.pageY - 15;

            if (left + tooltipWidth > window.innerWidth) left = event.pageX - tooltipWidth - 15;
            if (top + tooltipHeight > window.innerHeight) top = event.pageY - tooltipHeight - 15;
            if (top < 0) top = 5;

            tooltip.style("display", "block").style("left", `${left}px`).style("top", `${top}px`);
        }

        /**
         * Hides the tooltip.
         * @param {boolean} force - If true, hides the tooltip even if it's pinned.
         */
        function hideTooltip(force = false) {
            if (force) {
                pinnedTooltipNode = null;
            }
            if (!pinnedTooltipNode) {
                tooltip.style("display", "none");
            }
        }

        // --- VISUAL EFFECTS ---
        /**
         * Highlights a node and its direct connections.
         * @param {object} d - The D3 data object for the hovered node.
         */
        function highlightRelated(d) {
            g.selectAll('.node').style('opacity', 0.2);
            g.selectAll('.link').style('opacity', 0.1);

            const connectedNodeIds = new Set([d.id]);
            g.selectAll('.link').filter(l => l.source.id === d.id || l.target.id === d.id)
                .style('opacity', 1)
                .each(l => {
                    connectedNodeIds.add(l.source.id);
                    connectedNodeIds.add(l.target.id);
                });

            g.selectAll('.node').filter(n => connectedNodeIds.has(n.id)).style('opacity', 1);
        }

        /**
         * Resets all nodes and links to full opacity.
         */
        function resetHighlight() {
            g.selectAll('.node, .link').style('opacity', 1);
        }

        /**
         * Resets the graph's zoom and pan to the default state.
         */
        function resetZoom() {
            svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);
        }

        // --- D3 DRAG HELPERS ---
        function drag(simulation) {
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            return d3.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended);
        }

        // --- UTILITY & GETTER FUNCTIONS ---
        const getNodeColor = d => ({ central: '#ff6b6b', narrower: '#8a68cc', broader: '#ff8c42', related: '#4a90e2', members: '#3498db' }[d.type] || '#ccc');
        const getNodeRadius = d => d.type === 'central' ? 20 : 10;
        const getDisplayLabel = name => keywordData[name]?.labels?.[currentLanguage]?.pref?.[0] || name;
        const getDefinition = name => keywordData[name]?.definitions?.[currentLanguage]?.[0] || keywordData[name]?.definitions?.en?.[0];
        const getCBVSourceURL = name => keywordData[name]?.uri ? `https://cbv.cwr.wto.org/showvoc/#/datasets/WTO_Thesaurus/data?resId=${encodeURIComponent(keywordData[name].uri)}` : null;
        
        function getTranslations(name) {
            const labels = keywordData[name]?.labels;
            if (!labels) return [];
            return ['es', 'fr'].reduce((acc, lang) => {
                if (labels[lang]?.pref?.length) {
                    acc.push(`${labels[lang].pref[0]} (${lang.toUpperCase()})`);
                }
                return acc;
            }, []);
        }

        function findParentCollections(keywordName) {
            return Object.values(keywordData)
                .filter(item => item.type === 'collection' && (item.members || []).includes(keywordName))
                .map(item => ({ name: getDisplayLabel(item.labels.en.pref[0]) }))
                .sort((a, b) => a.name.localeCompare(b.name));
        }

        function navigateToTopic(topicName) {
            document.getElementById('search-input').value = '';
            document.getElementById('search-suggestions').style.display = 'none';
            const newUrl = `?keyword=${encodeURIComponent(topicName)}`;
            window.history.pushState({ topic: topicName }, '', newUrl);
            drawGraph(topicName);
        }

        function switchLanguage(lang) {
            currentLanguage = lang;
            document.querySelectorAll('.lang-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.lang === lang));
            updateUIText();
            if (currentKeyword) {
                drawGraph(currentKeyword); // Redraw graph with new language
            }
        }

        // --- MULTILINGUAL TEXT ---
        const UI_TEXTS = {
            en: {
                mainMenu: 'Main Menu', resetZoom: 'Reset Zoom', searchPlaceholder: 'Search for a keyword...', topic: 'Topic',
                centralTopic: 'Central Topic', narrowerTerms: 'Narrower Terms', broaderTerms: 'Broader Terms', relatedTerms: 'Related Terms', collectionMembers: 'Collection Members',
                relatedTopics: 'Related Topics', broaderTopics: '‚ñ≤ Broader Topics', narrowerTopics: '‚ñº Narrower Topics', relatedTopics: '‚óÜ Related Topics', membersTopics: '‚òÖ Collection Members', parentCollections: 'üìÅ Parent Collections',
                doubleClickToExplore: 'Double-click node to explore', also: 'Also'
            },
            es: {
                mainMenu: 'Men√∫ Principal', resetZoom: 'Reiniciar Zoom', searchPlaceholder: 'Buscar una palabra clave...', topic: 'Tema',
                centralTopic: 'Tema Central', narrowerTerms: 'T√©rminos Espec√≠ficos', broaderTerms: 'T√©rminos Amplios', relatedTerms: 'T√©rminos Relacionados', collectionMembers: 'Miembros de Colecci√≥n',
                relatedTopics: 'Temas Relacionados', broaderTopics: '‚ñ≤ Temas Amplios', narrowerTopics: '‚ñº Temas Espec√≠ficos', relatedTopics: '‚óÜ Temas Relacionados', membersTopics: '‚òÖ Miembros de Colecci√≥n', parentCollections: 'üìÅ Colecciones Padre',
                doubleClickToExplore: 'Doble clic para explorar', also: 'Tambi√©n'
            },
            fr: {
                mainMenu: 'Menu Principal', resetZoom: 'R√©initialiser le Zoom', searchPlaceholder: 'Rechercher un mot-cl√©...', topic: 'Sujet',
                centralTopic: 'Sujet Central', narrowerTerms: 'Termes Sp√©cifiques', broaderTerms: 'Termes Plus Larges', relatedTerms: 'Termes Connexes', collectionMembers: 'Membres de la Collection',
                relatedTopics: 'Sujets Connexes', broaderTopics: '‚ñ≤ Termes Plus Larges', narrowerTopics: '‚ñº Termes Sp√©cifiques', relatedTopics: '‚óÜ Termes Connexes', membersTopics: '‚òÖ Membres de la Collection', parentCollections: 'üìÅ Collections Parentes',
                doubleClickToExplore: 'Double-cliquez pour explorer', also: 'Aussi'
            }
        };
        const getText = (key) => UI_TEXTS[currentLanguage]?.[key] || UI_TEXTS.en[key];

        // --- INITIALIZATION ---
        /**
         * Initializes the application.
         */
        async function init() {
            await loadData();
            if (allKeywords.length === 0) return;

            const initialTopic = new URLSearchParams(window.location.search).get('keyword') || allKeywords[Math.floor(Math.random() * allKeywords.length)].name;
            
            initializeEventListeners();
            updateUIText();
            drawGraph(initialTopic);
        }

        init();
    </script>
</body>
</html>